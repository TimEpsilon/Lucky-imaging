#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jun  9 09:58:47 2022

@author: tdewacher
"""

import numpy as np 
from image_registration import chi2_shift
from image_registration.fft_tools import shift
import os
from astropy.io import fits
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import pandas as pd
import time
import datetime
from matplotlib.colors import PowerNorm

FWHM_TO_SIGMA = 2*np.sqrt(2*np.log(2))

def align(offset,image):
    """
    Aligns offset to image.

    Parameters
    ----------
    offset : 2D array
        The image to align.
    offset : 2D array
        The reference image to align to.

    Returns
    -------
    corrected : 2D array
        The offset image after alignement with image
    """
    xoff, yoff, exoff, eyoff = chi2_shift(image, offset)
    
    return shift.shiftnd(offset,[-yoff,-xoff])

def align_datacube(datacube):
    '''
    Aligns every image to the first one of the cube.

    Parameters
    ----------
    datacube : 3D array [time,x,y]
        The set of images to align.

    Returns
    -------
    aligned: 3D array [time,x,y]
        The aligned set of images

    '''
    ref = gauss_map(np.shape(datacube)[1], np.shape(datacube)[2], np.max(datacube[0,:,:]))
    # For every frame
    for i in range(np.shape(datacube)[0]):
        datacube[i,:,:] = align(datacube[i,:,:],ref)
        
    return datacube

def gauss_map(dx,dy,A):
    Y,X = np.indices()
    return Gauss2D([X,Y],A,5,dx/2,dy/2,0)
    
# def radius_map(dx,dy):
#     '''
#     Returns a 2D array of size (dx,dy) where each value is the distance to the center

#     Parameters
#     ----------
#     dx : int
#         horizontal size.
#     dy : int
#         vertical size.

#     Returns
#     -------
#     map : 2D array
#         The radius map.

#     '''
    
#     x,y = np.arange(0,dx), np.arange(0,dy)
#     X,Y = np.meshgrid(x,y)
    
#     X = X - dx/2
#     Y = Y - dy/2
    
#     return np.sqrt(X**2 + Y**2)

def Gauss2D(XY,A,fwhm,x0,y0,c):
    '''
    2D gauss function

    Parameters
    ----------
    XY : [X,Y]
        Array containing the values (array or single) of x and y.
    A : nbr
        Max value.
    fwhm : nbr
        Full Width at Half max.
    x0 : nbr
        x component of the center.
    y0 : nbr
        y component of the center.
    c : nbr
        offset on the z axis.

    Returns
    -------
    Z: array/nbr
        The value at (X,Y)

    '''
    x,y = XY
    s = fwhm/FWHM_TO_SIGMA
    
    return A * np.exp(-((x-x0)**2 + (y-y0)**2)/(2*s**2)) + c
    
def Gauss2D_ravel(XY,A,fwhm,x0,y0,c):
    return np.ravel(Gauss2D(XY,A,fwhm,x0,y0,c))

def get_gaussian_to_image(img):
    '''
    Returns the parameters needed for Gauss2D, fitted from an image.

    Parameters
    ----------
    img : 2D array
        The image to fit the gaussian to.

    Returns
    -------
    A : nbr
       Max value.
   fwhm : nbr
       Full Width at Half max.
   x0 : nbr
       x component of the center.
   y0 : nbr
       y component of the center.
   c : nbr
       offset on the z axis.

    '''
    guess = [np.max(img),10,0,0,0]
    
    y,x = np.indices(np.shape(img))
    x = x - np.shape(x)[1]/2
    y = y - np.shape(y)[0]/2
    
    try:
        popt, pcov = curve_fit(Gauss2D_ravel,(x,y),img.ravel(),p0=guess)
    except RuntimeError:
        print("\033[93m RunTimeError", " Sending back absurd values")
        popt = [0,1000,0,0,0]
        pass
    
    return popt

def get_fwhm_from_datacube(datacube):
    '''
    Returns an array containing the fwmh from the curve fitted gaussian for every frame of the datacube.
    Datacube must be aligned first.

    Parameters
    ----------
    datacube : 3D array [time,x,y]
        The set of images to get fwhm from.

    Returns
    -------
    fwhm : array
        The value of each fwmh corresponding to every frame of the datacube.

    '''
    fwhm = [get_gaussian_to_image(datacube[i,:,:])[1] for i in range(np.shape(datacube)[0])]
    
    return fwhm

def get_fwmh_from_datacube_smart(datacube,verbose=False):
    '''
    Returns an array containing the fwmh from the curve fitted gaussian for every frame of the datacube.
    Also aligns the datacube.

    Parameters
    ----------
    datacube : 3D array [time,x,y]
        The set of images to align.

    Returns
    -------
    fwhm : array
        The value of each fwmh corresponding to every frame of the datacube.

    '''
    fwhm = []
    # For every frame
    ti = time.time()
    for i in range(np.shape(datacube)[0]):
        datacube[i,:,:] = align(datacube[i,:,:],datacube[0,:,:])
        if verbose and i%100 == 0 : print("Aligning image "+str(i))
        fwhm.append(get_gaussian_to_image(datacube[i,:,:])[1])
        if verbose and i%100 == 0: print("Getting the fwhm for " + str(i))
    tf = time.time()
    
    print(f"Execution time : {tf-ti}")
    
    plt.show()
    return fwhm

def get_percent_best(datacube,percent):
    '''
    Returns an array containing the indices of the top percent % frames of the datacube.
    Based on how small the corresponding fwhm is.

    Parameters
    ----------
    datacube : 3D array [time,x,y]
        The set of images to align.
    percent : int
        % of frames to keep.

    Returns
    -------
    indices : array
        Contains the indices of the best frames in the datacube.

    '''
    # Sorts and keeps the lowest fwhd
    fwhm = get_fwmh_from_datacube_smart(datacube,verbose=True)
    df = pd.DataFrame(fwhm)
    df = df.sort_values(by=0)
    return df.index[:int(min(100,percent)/100*len(df))]

def get_mean_image_best(datacube,percent):
    '''
    Returns a 2D array representing the mean of percent % best images in the datacube.
    Based on how small the corresponding fwhm is.

    Parameters
    ----------
    datacube : 3D array [time,x,y]
        The set of images to align.
    percent : int
        % of frames to keep.

    Returns
    -------
    mean : 2D array
        Mean image.

    '''
    index = get_percent_best(datacube, percent)
    return np.mean(datacube[index,:,:],axis=0)

def save_mean_image_best(name,percent=20):
    '''
    Saves to file the mean of the given datacube, after selecting the percent % best ones.

    Parameters
    ----------
    name : str
        Path to the file .fits.
    percent : int
        % of frames to keep.

    '''
    # Checking if file exists and valid
    if not os.path.exists(name) or not ".fits" in name:
        return
    
    # Copy of datacube
    with fits.open(name) as hdul:
        hdul.writeto(name.replace("clean", "mean")
                               ,output_verify='silentfix',overwrite=True)
    
    # Open export
    with fits.open(name.replace("clean", "mean"),mode='update') as hdul:
        img = hdul[0].data
        hdr = hdul[0].header
        
        # Replace properties in header
        hdr.set("ORIGFILE",hdr.get("ORIGFILE").replace("CLEAN","MEAN"))
        hdr.set("HIERARCH ESO DPR TYPE",'MEAN')
        hdr["HISTORY"] =  [hdr.get("HISTORY"), datetime.date.today().ctime().replace(':','-') + " - Align and mean"]
    
        # Replacing hdr, img
        print("\033[92m"+"Working on : " + name)
        hdul[0].data = get_mean_image_best(img, percent)
        hdul[0].header = hdr
        print("\033[92m"+ name.replace("clean", "mean") + " saved!")
    return

main = "/home/tdewacher/Documents/Stage/" 
folders = ["P82-2008-2009","P88-2011-2012","P90-2012-2013","P94-2014-2015"]

for f in folders:
    for obj in os.listdir(main+f):
        if obj =="ObjectNameNotSet": 
            continue
        for times in os.listdir(main+f+"/"+obj):
            for filt in os.listdir(main+f+"/"+obj+"/"+times):
                if os.path.exists(main+f+"/"+obj+"/"+times+"/" + filt + "/export"):
                    for clean in os.listdir(main+f+"/"+obj+"/"+times+"/" + filt + "/export"):
                        file = main+f+"/"+obj+"/"+times+"/" + filt + "/export/" + clean
                        if "clean" in file:
                            save_mean_image_best(file)
